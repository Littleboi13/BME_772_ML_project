%% BME 772 Final Project Filtering Code
% Data Truncation -> Filtering -> *Feature Extraction* -> Machine Learning
% Feature Extraction: Time Domain, Frequency Domain, Decomposition Domain, Time-Frequency Domain, Nonlinear/Dynamical
% Student IDs: Jacklyn D'Ascenzo (xxxxx7753), Mya Hao (xxxxx8133), Tanvir Hassan (xxxxx4056), Janneza Macaalay (xxxxx2196)

%% Time Domain Feature Extraction
function [meanEEG, stdEEG, first_D, second_D, AR_coeff] = time_domain_features(signal)
    numCh = size(signal, 1); 
    numSamples = size(signal, 2);

    % Preallocate output variables
    meanEEG = zeros(numCh, 1);
    stdEEG = zeros(numCh, 1);
    first_D = zeros(numCh, numSamples-1);
    second_D = zeros(numCh, numSamples-2);
    AR_coeff = cell(numCh, 1);
    
    for ch = 1:numCh
        x = signal(ch,:);

        % 1. Mean and Standard Deviation
        meanEEG(ch) = mean(x);
        stdEEG(ch) = std(x);

        % 2. First and Second Differences
        first_D(ch, :) = diff(x, 1);
        second_D(ch, :) = diff(x, 2);

        % 3. Determine AR order using AIC
        N = length(x);
        pmax = 10;
        AIC = zeros(pmax, 1);
        for p = 1:pmax
            [~, e] = aryule(x, p); % AR model
            AIC(p) = 2*p + N*log(e); % AIC formula
        end
        [~, AR_order_opt] = min(AIC);

        % 4. Compute AR coefficients with optimal order
        [a, ~] = aryule(x, AR_order_opt);
        AR_coeff{ch} = -a(2:end);  % exclude leading 1, store as row vector
    end
end

%% Frequency Domain Feature Extraction
function [alpha_fPower, beta_fPower, gamma_fPower, delta_fPower, theta_fPower] = feature_domain_bandPower(signal, Fs)
    % α = 8–13 Hz; β = 13–30Hz; γ = 30–100Hz; δ = 0.5–4Hz; θ = 4–8Hz;
    signal = double(signal);
    numCh = size(signal, 1);

    % Preallocate output variables
    alpha_fPower = zeros(numCh, 1);
    beta_fPower  = zeros(numCh, 1);
    gamma_fPower = zeros(numCh, 1);
    delta_fPower = zeros(numCh, 1);
    theta_fPower = zeros(numCh, 1);

    for ch = 1:numCh
        x = signal(ch,:);
        alpha_fPower(ch) = bandpower(x, Fs, [8 13]);
        beta_fPower(ch)  = bandpower(x, Fs, [13 30]);
        gamma_fPower(ch) = bandpower(x, Fs, [30 100]);
        delta_fPower(ch) = bandpower(x, Fs, [0.5 4]);
        theta_fPower(ch) = bandpower(x, Fs, [4 8]);
    end
end

function [spectral_Entropy, PSD, FT] = feature_domain_spectral_features(signal, Fs)
    signal = double(signal);
    numCh = size(signal, 1);

    % Preallocate output variables
    spectral_Entropy = zeros(numCh, 1);
    nfft = max(2^nextpow2(Fs), 1024);
    PSD = zeros(numCh, nfft/2+1);  
    FT  = zeros(numCh, nSamples); 

    winLength = min(round(Fs*2), length(signal));  % window max 2 sec or signal length
    overlap   = floor(winLength/2);
    f = linspace(0, Fs/2, nfft/2+1);
    
    for ch = 1:numCh
        x = signal(ch, :);
        % Spectral Entropy
        spectral_Entropy(ch) = spectralEntropy(x, Fs);
        % Power Spectral Density
        [Pxx, ~] = pwelch(x, hamming(winLength), overlap, nfft, Fs);
        PSD(ch,:) = Pxx;
        % Fourier Transform
        FT(ch,:) = abs(fft(x)).^2;  % power spectrum (FFT returns complex: abs(FFT) = magnitude (sqrt(Re^2+Im^2)); squaring gives power)
    end
end

%% Extracting the features
Fs = 256; % Sampled at 256 samples per second
inputDir = 'data_truncated';
outputDir = "Dataset";

files = dir(fullfile(inputDir, '**', '*.mat'));
fprintf("Found %d files.\n", numel(files));

%% Start filing
for i = 1:numel(files)
    fprintf("\nProcessing %d of %d: %s\n", i, numel(files), files(i).name);
    % 1. Extracting the EEG
    filePath = fullfile(files(i).folder, files(i).name);
    data = load(filePath);
    
    if ~isfield(data, 'segment')
        warning("File %s has no 'segment' field. Skipping.\n", files(i).name);
        continue;
    end

    eeg = data.segment;   

    % 2. Detrending and DC Offset Removal
    clean_eeg = cleaning(eeg);

    % 3. Finding the Powerline Noise
    [lineFund, lineHarm] = detect_line_frequency(clean_eeg, Fs);

    % 4. Notch Filter for Powerline Noise
    notch_eeg = apply_notch(clean_eeg, Fs, lineFund, lineHarm);

    % 5. Broad Bandpass
    bp_eeg = broad_bandpass(notch_eeg, Fs);

    % 7. Saving the Clean Signals
        % Creating the New Subfolders
    relPath = files(i).folder(length(inputDir)+1:end);
    if startsWith(relPath, filesep)
        relPath = relPath(2:end);
    end

        % Path for the New Subfolder
    outFolder = fullfile(outputDir, relPath);

        % Create a New Folder if it Does Not Exist
    if ~exist(outFolder, 'dir')
        mkdir(outFolder);
    end
        % Names for the New Filtered Data
    [~, base, ~] = fileparts(files(i).name);
    outFile = fullfile(outFolder, base + "_filtered.mat"); 

    bp_eeg_transposed = bp_eeg'; % Transpose the matrix before saving
    save(outFile, "bp_eeg_transposed"); % Append the transposed data

end

