%% BME 772 Final Project Filtering Code
% Data Truncation -> *Filtering* -> Feature Extraction -> Machine Learning
% Filtering: Detrend -> Notch (Fundamental + Harmonic) -> Bandpass -> ICA
% Student IDs: Jacklyn D'Ascenzo (xxxxx7753), Mya Hao (xxxxx8133), Tanvir Hassan (xxxxx4056), Janneza Macaalay (xxxxx2196)

%% Detrending and Removal of DC Offset
function clean_EEG = cleaning(signal)
    % Removing the NaN channels in the Data
    signal(all(isnan(signal), 2), :) = [];

    % Detrending the data
    signal = detrend(signal')';

    % Removal of DC Offset
    clean_EEG = signal - mean(signal, 2); % remove DC offset per channel
end

%% Notch Filter Function
    % Finding the Powerline Noise -> Either 50Hz or 60Hz depending on the equipment
        % Hospitals Use 60Hz Power Sources (North American Devices) and 50Hz Power Sources (Internationally Imported Devices)
function [lineFreqFund, lineFreqHarm] = detect_line_frequency(signal, Fs)
    % Only using one EEG channel as reference for this
    ref = signal(1,:);

    % Finding PSD with pwelch
    desiredWin = round(Fs*2);
    winLength = min(desiredWin, length(ref));   
    win = hamming(winLength);
    overlap = floor(winLength*0.5); 
    nfft = max(2^nextpow2(winLength), 1024); %(Δf = Fs/NFFT)
    
    [pxx, f] = pwelch(ref, win, overlap, nfft, Fs); % FFT of each to get Power -> hamming is a windowing function

    % Finding the Powerline Noise Frequency Fundamental Frequency
    idx_fund = f >= 45 & f <= 65;
    [~, i1] = max(pxx(idx_fund));
    lineFreqFund = f(idx_fund);
    lineFreqFund = lineFreqFund(i1);

    % Finding the Harmonics of the Powerline Noise
    idx_harm = f >= 95 & f <= 125;
    [~, i2] = max(pxx(idx_harm));
    lineFreqHarm = f(idx_harm);
    lineFreqHarm = lineFreqHarm(i2);
end

    % Notch Filter for Determined Powerline Noise
function sig_filtered = apply_notch(signal, Fs, lineFreqFund, lineFreqHarm)
    Q = 60;  % notch sharpness (higher = narrower band)
    sig_filtered = zeros(size(signal)); % initializing the output variable

    for ch = 1:size(signal, 1)
        sig = double(signal(ch,:)); % ensuring type double for iirnotch function

        % Fundamental Frequency Notch
        if lineFreqFund > 0 && lineFreqFund < Fs/2 % freq cannot be negative and it must be less than half the sampling
            W0 = lineFreqFund/(Fs/2);
            BW = W0/Q;
            [bF, aF] = iirnotch(W0, BW);
            sig = filtfilt(bF, aF, sig);
        end

        % Harmonic Frequency Notch
        if lineFreqHarm > 0 && lineFreqHarm < Fs/2
            W0 = lineFreqHarm/(Fs/2);
            BW = W0/Q;
            [bH, aH] = iirnotch(W0, BW);
            sig = filtfilt(bH, aH, sig);
        end

        sig_filtered(ch, :) = sig;
    end
end

%% Bandpass Filtering
    % Broad Bandpass for Removing Baseline Drift and High Frequency EMG Noise
function sig_bp = broad_bandpass(signal, Fs)
    Fpass = [0.5 100]; % 0.5 (min of delta) –100 (max of gamma) Hz bandpass for EEG
    order = 4; % 4th order Butterworth
    [bB,aB] = butter(order, Fpass/(Fs/2), 'bandpass');
    sig_bp = zeros(size(signal)); % initializing the bandpass output vector

    for ch = 1:size(signal, 1)
        sig_bp(ch,:)  = filtfilt(bB, aB, double(signal(ch, :)));
    end
end
    % α = 8–13 Hz; β = 13–30Hz; γ = 30–100Hz; δ = 0.5–4Hz; θ = 4–8Hz;
%% Independent Component Analysis
function ICA_sig = ICA(signal)
    if size(signal, 1) == 1
        warning("ICA cannot run with only one channel. Returning original signal.");
        ICA_sig = signal;
        return;
    end

    % Transpose for ICA (rows = samples, columns = channels)
    X = signal';

    % Remove channels that are all NaN, Inf, or constant
    rowsToKeep = ~all(isnan(X) | isinf(X) | X==0, 2) & std(X,0,2)~=0;
    X_clean = X(rowsToKeep, :);

    if isempty(X_clean)
        warning("All channels are invalid after cleaning. Returning original signal.");
        ICA_sig = signal;
        return;
    end

    % Check rank
    rankX = rank(X_clean);
    if rankX < size(X_clean, 2)
        % Add tiny jitter to break exact linear dependence
        X_clean = X_clean + 1e-12*randn(size(X_clean));
    end

    % Use PCA only to reduce dimensionality if necessary
    [~, score] = pca(X_clean, 'Economy', true);
    numComp = min(rank(X_clean), size(score,2));
    score = score(:, 1:numComp);

    % Run RICA with high iteration limit and small regularization
    Mdl = rica(score, numComp, 'Lambda', 1e-4, 'IterationLimit', 5000, 'Standardize', true, 'Verbose', 0);
    IC = transform(Mdl, score);

    % Return to original format (channels x samples)
    ICA_sig = IC';
end

%% Applying the Filtering Sequence
Fs = 256; % Sampled at 256 samples per second
inputDir = 'C:\Users\Jackl\OneDrive\Desktop\BME_772_ML_project\data_truncated';
outputDir = "C:\Users\Jackl\OneDrive\Desktop\BME_772_ML_project\Filtered_Data";

files = dir(fullfile(inputDir, '**', '*.mat'));
fprintf("Found %d files.\n", numel(files));

for i = 1:numel(files)
    fprintf("\nProcessing %d of %d: %s\n", i, numel(files), files(i).name);
    % 1. Extracting the EEG
    filePath = fullfile(files(i).folder, files(i).name);
    data = load(filePath);
    
    if ~isfield(data, 'segment')
        warning("File %s has no 'segment' field. Skipping.\n", files(i).name);
        continue;
    end

    eeg = data.segment;   

    %2. Detrending and DC Offset Removal
    clean_eeg = cleaning(eeg);

    % 3. Finding the Powerline Noise
    [lineFund, lineHarm] = detect_line_frequency(clean_eeg, Fs);

    % 4. Notch Filter for Powerline Noise
    notch_eeg = apply_notch(clean_eeg, Fs, lineFund, lineHarm);

    % 5. Broad Bandpass
    bp_eeg = broad_bandpass(notch_eeg, Fs);

    % 6. Independent Component Analysis
    ICA_eeg = ICA(bp_eeg);

    % 7. Saving the Clean Signals
        % Creating the New Subfolders
    relPath = files(i).folder(length(inputDir)+1:end);
    if startsWith(relPath, filesep)
        relPath = relPath(2:end);
    end

        % Path for the New Subfolder
    outFolder = fullfile(outputDir, relPath);

        % Create a New Folder if it Does Not Exist
    if ~exist(outFolder, 'dir')
        mkdir(outFolder);
    end
        % Names for the New Filtered Data
    [~, base, ~] = fileparts(files(i).name);
    outFile = fullfile(outFolder, base + "_filtered.mat"); 

        % Saving the New Filtered Data
    save(outFile, "bp_eeg", "ICA_eeg");
end

%% Plotting the First EEG
figure;

t = (0:size(input_eeg,2)-1) / Fs;

subplot(2,1,1);
plot(t, input_eeg(1,:));
title('Input EEG (Channel 1)');
xlabel('Time (s)');
ylabel('Amplitude');
grid on;

subplot(2,1,2);
plot(t, output_eeg(1,:));
title('Output EEG (Channel 1)');
xlabel('Time (s)');
ylabel('Amplitude');
grid on;

sgtitle('Input vs Output EEG — Time Domain');
